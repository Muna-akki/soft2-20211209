# soft2-20211209
## 1
struct_alignment.cとstruct_alignment.mdに、指示通りの内容を書いている。
## 2以降
### 共通部分について
falling.cとbouncing.cではmy_**系の関数を仕様に従って実装している。以後の課題ではbouncing.cをもとに作っている(そのため関数のプロトタイプ宣言等はphysics2.hにて行った)。なお、bouncing.cにおいては例えば以下のように反射後の座標を決めているため、速度が速すぎた場合は引き算の結果反対側の壁を通り越してしまうこともある。しかし、このようにして座標を決めた場合に、用意されたライブラリによる試行と同じ結果になったため、ここではいじっていない。もちろん、一瞬の間に速度が十分小さくなるまで何度も反射を繰り返すことで範囲内に収めることはできるが、そこまで速度が速い場合、限られた画面、時間解像度ではobjectの高速移動を捉えきれず、シミュレーションの結果を視覚的に捉えるという目的にそぐわない。そこで、このような場合には「力学的エネルギーが高すぎて壁を破壊して吹っ飛んでいった」と解釈し、特別な考慮はしないことにした。
```c
if(objs[i].prev_y<cond.height/2.0 && objs[i].y>cond.height/2.0){
			objs[i].y = cond.height-objs[i].y;
			objs[i].prev_vy = -cond.cor*objs[i].vy;
			objs[i].vy = -cond.cor*objs[i].vy;
		
		}
```

### 2
二次元への拡張にあたって、まずはphysics.2における構造体の定義にx方向に関する定義を加えた。その後、bouncing.cにおける各種関数にx方向の操作をyと同様に書き加え、main内で物体数を適当に増やしてmy_bouncing1.cとした。bouncing.cの段階で加速度の変更等をforループで行っていたため、書き換えはそう多くならなかった。

### 3
テストに使ったファイルはdata.datである。
read_file()関数を定義。この関数ではまず#から始まる行が何行あるかをカウントしファイル位置を物体の情報が始まる行にセットした後、物体の情報を決まったフォーマットで読み込む。与えられた個数の分だけループを回し、その個数よりファイル内容が多い場合はその部分を無視、逆に少ない場合はその分だけ質量0、x座標がwidth、y座標がheight(表示領域の外)、速度0、となるように物体を作る。

なお、オイラー法による計算法では、質量が0の物体は他の物体に影響を与えることはないが、他からの影響は受けてしまい加速度が0にならない。しかし、ここではそもそもファイル内で「質量0、速度≠0」という指定もできてしまう。これらの場合について、一応速度更新の際に質量0なら加速度0とはしているが、mがdoubleである関係で、==の判定が綺麗に動かない可能性がある。これに関しては、
- 与えられた個数に足りなかった分の質量0物体は画面外であり見た目に大した影響はない
- ファイル内に与えられた質量0については許容せざるを得ない

という理由からそれぞれこの程度の対策で手打ちとした。

### 4 
物体の衝突(融合)の実現のためcollision()関数を定義した。この関数では任意の二つの物体の組に対して距離を計算し、距離が一定値以下であればインデックスの早い方に質量・運動量が保存されるように統合する。インデックスの遅い方は質量0の静止物体として画面外に出てもらう。

### 5